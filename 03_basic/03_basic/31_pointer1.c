/*
	모든 데이터들은 메모리 상의 특정 공간에 저장되어 있다.
	편의를 위해 특정한 공간을 '방'이라고 하자. 각 방에는 데이터들이 들어가게 된다.

	그 방의 크기는 보통 1byte로 정의 된다. 만약 우리가 4byte짜리 int형 변수를 정의하면 메모리 상에 4칸을 차지하게 된다.

	프로그램 작동 시 컴퓨터는 여러 방들에 있는 데이터를 필요로 하게 된다.
	따라서, 어떤 방에서 데이터를 가져올 지 구분하기 위해 각 방에 고유의 주소(address)를 붙여준다.

	예를 들어 int a = 123; 이라고 변수 a를 정의했다면, 특정한 방에 4칸을 차지하는 123이란 값을 담은 변수 a가 정의된다.
	그리고 이 방의 시작주소를 임의로 0x152839라고 하자. (시작 주소 기준으로 4byte를 차지하는 방이다)

	그리고 나서 a = 10이라고 하면
	0x152839위치에서 부터 4byte의 공간에 있는 데이터를 10으로 바꾼다.

	만약 컴퓨터가 32bit 운영체제라면 컴퓨터들의 주소값의 크기가 32bit(즉 4byte)로 나타내진다.
	= 주소값이 0x0000 0000 ~ 0x FFFF FFFF까지의 값을 가진다.
	(요즘은 거의 64bit 운영체제를 사용한다.)

	여기서 32 bit로 사용할 수 있는 주소값의 가지수는 2^32 byte, 
	즉 RAM은 최대 4GB까지 밖에 사용할 수 없다는 사실을 알 수 있다.

	그런데 C를 만든 사람은 아주 유용한 '포인터'라는 것을 만들었다.
	포인터는 int나 char 변수들과 다른 것이 전혀 아니다. 포인터도 '변수'이다.
	int형 변수가 정수 데이터, flaot형 변수가 실수 데이터를 보관했던 것처럼, 포인터도 특정한 데이터를 보관하는 변수이다.

	포인터는 데이터가 저장된 주소값을 보관하는 변수이다.
	이 부분을 그냥 외우자! "포인터는 데이터가 저장된 (시작)주소값을 보관하는 변수"이다.

	변수를 정의할 때 int나 char처럼 type이 있다. 그리고 포인터에도 type이 있다.
	이 말은 포인터가 메모리 상의 int형 데이터의 주소값을 저장하는 포인터와 char 형 데이터의 주소의 값을 저장하는 포인터가 서로 다르다는 것이다.

	그런데 포인터는 주소값을 저장하는 거고, 우리가 주로 사용하는 컴퓨터는 주소값이 64bit = 8Byte이다.
	[1]그러면 포인터의 크기는 모두 동일한 것 아닌가? 그런데 왜 포인터는 type을 가지는가?

	[ === &연산자 === ]
	데이터가 저장된 주소값을 보관하는 변수인 포인터를 정의하였으면 값을 집어넣어야하는데
	우리는 데이터의 주소값을 어떻게 알까? 이는 바로 &연산자 때문이다.

	그런데 &가 bit에서 AND 연산자로 알고 있는데??
	bit 연산을 위한 AND 연산자의 사용은 2개의 피연산자를 요구한다
	a&b; 는 되지만 a&는 안된다.

	그런데 우리가 현재 사용할 &연산자는 오직 피연산자가 1개인 단항(unary) 연산자이다.
	고로 bit연산을 위한 AND 연산자와는 다르게 해석된다.
	단항 &연산자는 피연산자의 주소값을 불러온다.

	예를 들어 어떤 변수 a의 주소값을 알고 싶다면 &a로 사용하면 된다.

*/

#include<stdio.h>

int main() {
	int a;
	a = 2;

	printf("%p \n", &a); // 실행마다 다른 결과를 보인다.
	// 위의 문장에서 &a(a의 주소값)을 %p(16진수 형태)로 출력하라고 명령했다.
	// 그런데 위에서 출력된 결과는 8byte(16진수로 16자리)가 아니다.
	// 주소 값은 언제나 8byte의 크기 즉 16진수로 16자리인데 앞에 0이 잘려서 출력되지 않는다.
	// 만약 위에서 출력된 것이 0x 7ffe 37d0 3104 라면 앞의 0이 생략되었을 뿐 0x 0000 7ffe 37d0 3104가 된다.

	//이제 pointer에 값을 넣어보자
	int* p;
	p = &a;
	printf("포인터 p에 들어있는 값 : %p \n", p); // 1)
	printf("int 변수 a가 저장된 주소 : %p \n", &a); // 2) : 1)과 동일한 결과를 보일 것이다.

	/*
		[ * 연산자]
		포인터는 데이터가 있는 시작 주소값을 보관하는 변수이다.
		이때 포인터는 주소값을 보관하는 데이터 형에 *를 붙임으로써 정의되고, & 연산자로 특정 데이터의 메모리상 주소값을 알아올 수 있다.

		&연산자가 어떤 데이터의 주소값을 얻는 연산자라면, 거꾸로 주소값에서 해당 주소값에 대응되는 데이터를 가져오는 연산자가 필요하고 이거이 *연산자이다.

		a*b; // a와 b를 곱하는 곱셈 연산자 (이항 연산자)
		a*; // 오류
		*a; // 단한 * 연산자.
		* 연산자의 역할은 "나(포인터)를 나에게 저장된 주소값에 위치한 데이터로 생각해줘!이다."
	*/
	int* p2;
	int a2;

	p2 = &a; // p2에 a2의 주소를 넣음
	a2 = 2;

	printf("a2 의 값 : %d \n", a2);
	printf("*p2 의 값 : %d \n", *p2); // p에 저장된 주소(변수 a의 주소)에 해당하는 데이터, 즉 변수 a자체를 의미

	// *과 관련된 예제를 하나 더 보자
	int* p3;
	int a3;

	p3 = &a3;	// 포인터 변수 p3에 a3의 주소값을 담게 함
	*p3 = 3;	// p3에 저장된 주소값에 위치한 데이터를 3으로 함

	printf("a 의 값 : %d \n", a3);
	printf("*p 의 값 : %d \n", *p3);
	/*
		포인터라는 말 자체의 의미를 생각해보자.
		int a = 3; 일 때, a가 0x12A3BE72라는 시작주소를 가지고 3이라는 값을 가지고 있다.

		포인터 p라는 변수가 ox12A3B388을 시작주소로 있을 때, int*p = &a; 를 하면
		0x12A3B388을 시작주소로 하는 공간에 a의 시작 주소인 0x12A3BE72가 들어가게 된다.

		이렇게 포인터 p에 어떤 변수 a의 주소값이 저장되어 있다면, 포인터 p는 변수 a를 가리킨다라고 말한다.
		그리고 포인터도 "데이터가 저장된 (시작)주소값을 보관하는 변수"이므로, 즉 변수이므로 자신의 주소값을 가지고 특정 메모리 공간을 차지한다.

		[포인터는 왜 타입이 있을까?]
		포인터는 주소값만 보관하는데 왜 타입이 필요할까?
		어차피 주소값은 32bit 시스템에선 8byte이고 64bit 시스템에선 8byte인데 pointer라는 타입을 만들면 알될까?

		pointer라는 타입이 있다고 가정하고 아래의 코드를 보자.
		int a;
		pointer *p;
		p = &a;
		*p = 4;
		
		컴퓨터 입장에선 위의 코드를 어떻게 해석할까? 마지막 *p = 4; 에서 문제가 된다.
		포인터 p에는 명백히 변수 a의 시작 주소 값이 들어가 있다. 
		여기서 문제는 a가 메모리에서 차지하는 모든 주소들의 위치가 들어간 것이 아니라, '시작주소'만 들어가 있다는 것이다.
		따라서, *p 라고 했을 때 컴퓨터는 메모리에서 얼마만큼을 읽어야 할지 알 길이 없다.

		한편 int* p;로 수정한다면 포인터 p가 int*라는 사실을 보고 이 포인터는 int 데이터를 가리키는 것을 알게 된다.
		따라서 시작주소로부터 정확히 4바이트를 읽어 들어 값을 바꾸게 된다.
	*/

	//Pointer도 변수이다. => 포인터에 들어간 주소값이 바뀔 수 있다.
	int a4;
	int b4;
	int* p4;

	p4 = &a4;
	*p4 = 2;
	p4 = &b4;
	*p4 = 4;

	printf("a4 : %d \n", a4); // 실행결과 2
	printf("b4 : %d \n", b4); // 실행결과 4


	return 0;
}