#include <stdio.h>

int main() {
	// int 의 경우 4byte(32bit) 라서 -2147483648 ~ 2147483647 까지의 정수 데이터를 보관할 수 있다.
	int a = 2147483647;
	printf(" a : %d \n", a);

	// int의 범위를 넘어가면 어떻게 될까?
	a++;
	printf("a : %d \n", a);// -214783648이 된다.

	return 0;
}

/*
	[양수의 끝 값에서 +1을 했는데 왜 음수 끝이 나왔을까?]
	수를 표현할 때 부호를 통해 음수인지 양수인지 나타낸다. -> 1bit를 부호 bit으로 사용한다. (0이면 양수, 1이면 음수)

	0111 : 0이므로 + 이고 111 이므로 7이다. => +7
	1111 : 1이므로 - 이고 111 이므로 7이다. => -7
	
	이러한 방식에는 0000 = 0이고 1000도 -0으로 0이므로 0이 두개가 되는 문제가 발생한다. 
	이러한 방식은 어떤 데이터가 0인지 확인하기 위해서 +0인지 -0인지 2번이나 확인해야한다.
	1) 즉 쓸데없이 컴퓨터 자원을 낭비하게 된다.

	그리고 양수의 음수 덧셈을 수행할 때 부호를 고려해서 수행해야 한다.
	0001과 0101을 도하면 0110이 되지만 0001과 1001을 더할 때는 1001이 사실은 -1이므로 뺄셈을 수행해야 한다.
	따라서 덧셈 알고리즘이 더 복잡해진다.

	double이나 float처럼 소수인 데이터를 다루는 방식에서는 물론 부호 비트를 도입해서 음수인지 양수인지를 표현한다.
	하지만 적어도 정수를 표현하는 방식에서는 부호 bit을 사용하는 방식은 문제가 있다.


	[2의 보수 표현법 (two's complement)]
	컴퓨터가 4bit만 기억한다고 생각하자. 
	x + (-x) = 0이 되어야한다는 것을 생각하고 -7을 찾아보자.
	7 은 2진수로 0111 이다 그럼 -7로 적절한 것은 1001이다.
	cpu는 4bit만 기억하면 되므로 10000가 되었을 때 가장 앞의 1은 버려져셔 0000이 된다.

	이렇게 덧셈을 고려했을 때 가장 자연스러운 방법으로 음수를 표현하는 방식을 '2의 보수 표현'이라고 한다.
	2의 보수 체계 하에서 부호를 바꾸려면 Not + 1을 하면 된다.

	그리고 어떤 수가 양수인지 음수인지 판단하는 방법은 MSB(가장 왼쪽 bit)이 부호 bit이라고 생각하면 된다.
	1101의 경우 MSB가 1이므로 음수이다. 이 수가 구체적으로 어떤 수 인지 알고 싶다면 보수를 구한 다음에 -를 붙이면 된다.
	1101 -> 0010 -> 0011 이다. 0011 은 3이다. 따라서 1101은 -3이다.

	이러한 2의 보수 표현법을 통해서 
	- 음수, 양수 사이 덧셈 시에 굳이 부홀르 고려하지 않고 덧셈을 수행해도 되고 
	- 맨 앞 비트로 부호를 빠르게 알아낼 수 있다.


	[다시 우리의 코드로 돌아가서]
	a에 int 최대값을 지어 넣었을 때 a에는 0111 1111 ... 1111이라는 값 0x 7FFF FFFF이 들어가 있을 것이다.
	여기서 +1을 하게 되면, CPU는 0x 7FFF FFFF 에 +1을 시킨다. 따라서 0x 8000 0000 이 되고 이진수로 1000 0000 ... 0000이 된다.
	이 0x 8000 0000을 2의 보수 표현법 체계하에서 반전하고 +1을하면 -0x 8000 0000 즉 -2147483648이 된다.

	이렇게 자료형의 최대 범위보다 큰 수를 대입하므로써 발생하는 문제를 '오버플로우(overflow)'라고 한다.
	C언어 차원에서 오버플로우가 발생했다는 사실을 알려주는 방법은 없어서 스스로 자료형의 크기를 신경써줘야한다.


	
*/