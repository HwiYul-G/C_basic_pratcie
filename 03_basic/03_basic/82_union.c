/*
	공용체(union)
	그다지 많이 사용하는 기능은 아니다. 
	하지만 C언어에서 제공하는 것들 중 하나이니 간단히 집고 넘어가자.

	공용체는 구조체와 달리 메모리를 '공유'한다.
	struct A{
		int i;
		char j;
	};
	-------------
	| int i | j |
	-------------

	union A{
		int i;
		char j;
	};
	------------
	| j  i     |
	------------
	int i와 char j가 차지하는 메모리 영역이 겹쳐진다.

	union(공용체)의 각 멤버들의 메모리 시작주소는 모두 동일하다.
	따라서 우리는 위 그림의 union A의 경우 j의 값을 변경함으로써
	i의 값을 변경할 수 있고 마찬가지로 i의 값을 변경함으로써 j의 값을 변경할 수 있게 된다.

*/

#include <stdio.h>
union A {
	int i;
	char j;
};

union B {
	int i;
	short j;
};

int main() {
	union A a;
	a.i = 0x12345678;
	printf("%x", a.j); // 78
	/*
		우리는 a의 j 멤버 값을 전혀 설정해 주지 않았다.
		그런데도 i에 0x12345678을 대입하자 j의 값이 78로 잘 나왔다.

		그런데 이상하다. 왜 78이 나왔을까?
		0x12가 나와야하는 것아닌가?

		분명히 i와 j가 동일한 주소값에 위치해 있고 i가 0x12345678로 메모리상에 있다면
		j는 처음 2개인 0x12가 되어야 하는 것 아닌가?

		하지만 컴퓨터에서는 수를 이렇게 보관하지 않는다.
	*/
	
	union B b; // j가 short형이기 때문
	b.i = 0x12345678;
	printf("%x", b.j); // 0x5678

	return 0;
}
/*
	== 빅 엔디안(Big Endian), 리틀 엔디안(Little Endian) == 
	컴퓨터에서 메모리에 수를 저장할 때, 우리가 생각하는 방법
	즉 낮은 주소값에 상위 비트를 적는 방식을  '빅 엔디안' 방식이라고 한다.

	정반대로 높은 주소값에 상위 비트를 적는 방식을 '리틀 엔디안'이라고 한다.

	현재 대부분은 x86 프로세서는 '리틀 엔디안' 방식을 사용하고 있고
	일부는 컴퓨터에서만 '빅 엔디안' 방식을 사용한다.

	먼저, 빅 엔디안에서 수를 어떻게 저장하는지 보자.
	int i = 0x12345678

	| &i |          &i+3 (포인터의 덧셈이 아니라 단순히 주소값에 3을 더한 것)
	--------------------
	| 12 | 34 | 56 | 78 |
	---------------------
	빅 엔디안에서는 j = 0x12가 된다.

	상식적으로는 위와 같은 방식으로 수를 저장하게 된다.
	하지만 이건 빅 엔디안 방식의 경우이다.

	우리가 사용하는 대부분의 프로세는 리틀 엔디안 방식이므로 아래와 같은 방식이다.

	| &i |          &i+3 (포인터의 덧셈이 아니라 단순히 주소값에 3을 더한 것)
	--------------------
	| 78 | 56 | 34 | 12 |  <-- 이 때, 메모리에 1byte를 기준으로 배치된다.
	---------------------		(다시 말해 12역시 역으로 21처럼 보관되는 것은 아니다.)
	| j  |
	따라서 리틀 엔디안에서 j = 0x78이 된다.


	union B {
		int i;
		short j;
	};
	이번에는 j가 short형(2byte)이므로 위와 같이 j가 2byte를 차지하게 된다.
	이때 왜 j의 값을 출력하면 0x7856이 나오지 않고 0x5678이 나올까?

	| &i |          &i+3 (포인터의 덧셈이 아니라 단순히 주소값에 3을 더한 것)
	--------------------
	| 12 | 34 | 56 | 78 |
	---------------------
	|  j      |
	i의 값을 출력하면 얼마가 나올까?
	당연히 0x12345678이 될 것이다.
	왜냐하면 컴퓨터는 자신이 메모리에 수를 '리틀 엔디안 방식'을 저장하고 있다는 사실을 알고 있기 때문이다.
	따라서, 이를 출력할 때는 적절히 변환하여 0x5678을 출력하게 된다.

*/