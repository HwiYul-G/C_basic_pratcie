/*
	이 내용은 일반적인 OS에서 실행 파일이 메모리에 load 될 때 상황을 가정한 그림이다.
	C언어 자체적으로는 stack이나 heap 영역을 따로 구분하지 않는다.
	하지만 대부분의 OS에서 프로그램을 실행한다면, 아래 그림 처럼 heap과 stack 영역을 구분해서 만들게 된다.

	=========================
	| stack(지역 변수가 위치) |  높은 메모리 주소
	|-------아래로------------|
	|-------위로--------------|
	| heap					 |
	|----------------------	-|
	| 데이터 영역			|
	| (전역 변수, 정적 변수)  |
	|------------------------|
	| Read-Only Data		|
	| 상수, literal			|
	|-----------------------|
	|code segment(코드영역   |	낮은 메모리 주소
	=========================

	프로그램이 실행 될 때 프로그램은 RAM에 적재된다.
	즉 프로그램의 모든 내용이 RAM 위로 올라온다. 
	여기서 '프로그램의 모든 내용'은 프로그램의 코드와 프로그램 데이터를 모두 의미한다.

	이렇게 RAM 위로 올라온느 프로그램의 내용을 크게 나누어서 Code Segment와 Data Segment로 분류할 수 있다.

	가장 먼저 주목할 부분은 Read-Only Data 부분이다.
	이전에 상수와 리터럴에 대해서 이야기 할 때 등장했는데 이 부분에 저장된 데이터 값들은 절대로 변경될 수 없다.
	다시 말해 궁극적으로 보호받는 부분이다.

	그 다음으로 그 위에 정적 변수와 전역 변수가 위치하는 데이터 영역이 있다.
	그 위에 바로 heap이 있고 stack이 있다. (heap은 나중에..)
	stack은 지역 변수가 거처하는 곳이다. stack의 특징으로는 지역 변수가 늘어나면 크기가 아래로 증가하다가
	지역 변수가 파괴되면 다시 스택의 크기는 위로 줄어든다.
	즉 스택이 늘어나는 방향은 메모리 주소가 낮아지는 방향(아래 방향)이다.

*/
#include <stdio.h>
int global = 3;	// global var -> data seg
int main() {
	int i;	// local var -> stack
	char* str = "Hello, World"; // literal -> Read-Only
	char arr[20] = "WHATTHEHECK";	// in stack

	printf("global : %p \n", &global);	// 1177010
	printf("i : %p \n", &i);	// 1af8c8
	printf("str : %p \n", str);	// 1175a28
	printf("arr : %p \n", arr);	// 1af8a0
	/*
		각 변수들의 주소값을 살펴보면서 메모리에 정말로 그렇게 배치 되었는 지 보도록 하자.
		프로그램 실행 시 프로그램이 RAM 어디에 위치하게 될지 아무도 몰라서 결과는 매번 바뀐다.
		하지만 그 주소값들을 비교하면 다르다.

		가장 먼저 Read Only Data인 str을 보면 str에는 Hello World 라는 literal의 주소값이 들어가 있다.
		다라서 str의 값을 출력했다면 Read Only 데이터의 위치를 대략 알 수 있다.
		예상 대로 출력된 주소값들 중 가장 작게 나온다.
		왜냐하면 Read Only data는 데이터 세그먼트 맨 아래에 위치해 있기 때문이다.

		두 번째로 전역변수인 global의 주소값을 살펴보면 str보다는 살짝 크지만 다른 것들보단 살짝 작음을 알 수 있다.
		global이 전역변수로 데이터 영역에 위치해 있기 때문이다.

		3번째로 i를 보면 지역변수이므로 stack에 존재한다. 
		stack은 지역변수를 추가할 수록 메모리 주소가 작아지는 방향으로 추가되므로
		stack 보다 나중에 추가된 arr의 주소값이 더 작다.
	*/

	return 0;
}