/*
	문자열은 영어로 string이라고 하는데, 원래의 의미는 실이다.
	그런데 문자열을 string이라 부르는 이유는 정말 문자열이 실처럼 문자들이 쭈르륵 나열된 것이기 때문이다.
	
	컴퓨터는 문자열을 실처럼 쭈르륵 나열해 저장한다. 즉 문자들의 벼열 char배열에 저장한다.

	char s[5];
	s[0] = 'H', s[1] = 'e', s[2] = 'l', s[3] ='l', s[4] = 'o'
	실질적으로 메모리에 저장된 값은 각 문자에 해당하는 '아스키 값'이다. 
	이를 문자로 생각하느냐, 숫자로 생각하느냐는 프로그래머의 마음이다.

	위와 같이 문자열 s를 정의했을 때
	만일 우리가 char 배열 s에 저장된 문자들을 화면에 출력한다고 하자. 
	위와 같은 경우 "s의 문자열을 출력해, 그 문자는 3개의 문자야"라고 말해줘야하는 불편함이 생긴다.
	즉 어디까지 인지 알 수 없다.

	문자열은 말그대로 문자들이 하나로 뭉쳐서 다니는 것이므로(만일 우리가 s의 문자열을 이용한다고 하면 첫 글짜 H만 이용할 것이 아니기에)
	문자열을 이용할 때마다 문자열의 길이를 알아야하는 불편한 일이 발생한다.

	따라서 C개발자들은
	char s[6];
	s[0] = 'H', s[1] = 'e', s[2] = 'l', s[3] ='l', s[4] = 'o', s[5] = 0
	처럼 사용하는 대안을 내놓았다.

	즉 문자열의 끝에 여기까지가 문자열이였습니다.라고 알려주는 종료 문자를 넣은 것이다.
	이 종료 문자는 아시크 값이 0이고, '\0'이라고도 나타낸다. 절대 문자 '0'과 헷갈리면 안된다.
	문자 0은 아스키 코드 값이 0이 아니라 48이다.
	흔히, 이 종료 문자를 가리켜서 널(Null)이라고 부른다.

	널 문자가 들어갈 공간이 있어야 하기 때문에 3글자라고 해도 배열은 4칸이 필요하다.
	이렇게 널 종료문자를 사용함으로 문자열의 끝을 쉽게 구할 수 있는 장점이 생긴다.
	문자열 s를 출력해줘 이건 3문자로 되어있어 라고 말할 필요 없이 s문자열을 출력해줘 라고 말해도
	컴퓨터가 알아서 null이 나올 때까지 출력해야지 하고 한다.
*/
#include <stdio.h>

int main() {
	// 이 3가지는 모두 동일한 null 이다.
	char null_1 = '\0';
	char null_2 = 0;
	char null_3 = (char)NULL; // 모두 대문자로 사용해야 한다

	char not_null = '0'; // 이것은 문자 '0'로 아스키코드 48이다.

	printf("NULL의 정수(아스키)값 : %d, %d, %d \n", null_1, null_2, null_3);// 0 0 0
	printf("'0'의 정수(아시)값 : %d \n", not_null); // 48
	// 위의 예제를 통해 우리는 문자열의 마지막에는 종료 문자로 NULL이나 '\0'이나 문자 0이 아닌 0이란 값 자체를 사용할 수 있음을 알았다.
	/*
		컴파일 시 아래와 같은 경고를 만나는 경우도 있다.
		warning C4047 : '초기화 중' : 'char'의 간접 참조 수준이 'void *'과(와) 다릅니다.
		대다수의 경구는 중요한 역할을 하지만 여기서의 경고는 별로 중요하지 않기 때문에 상관하지 않아도 된다.
	*/

	//아래 예제를 통해 문자열을 더 확실히 공부하자.
	char sentence_1[4] = { 'P', 's', 'i', '\0' };
	char sentence_2[4] = { 'P', 's', 'i', 0 };
	char sentence_3[4] = { 'P', 's', 'i', (char)NULL };
	// 작은 따옴표로 배열에 하나하나 나눠서 문자열을 저장하는 것은 번거로운 일이다.
	// 따라서 아래와 같이 ""를 통해 묵어주면 알아서 문자로 넣어준다. 이때 NULL문자는 뒤에 자동으로 추가되니 굳이 큰따옴표 안에 명시할 필요는 없다.
	// 흔히 하는 실수가 "Psi"를 정의해놓고 배열의 크기를 3으로 잡는 경우가 있기 때문이다. 그러면 sentence의 끝에 NULL이 들어가지 않아
	// sentence의 문자열을 출력하라고 했을 때 NULL이 언제 나올지 모르므로 허용되지 않는 메모리 범위를 읽게되는 문제가 발생한다.
	// 반드시 NULL을 위한 공간 하나를 더 추가해야한다.
	char sentence_4[4] = { "Psi" };	

	printf("sentence_1 : %s \n", sentence_1);  // %s 를 통해서 문자열을 출력한다.
	printf("sentence_2 : %s \n", sentence_2);
	printf("sentence_3 : %s \n", sentence_3);
	printf("sentence_4 : %s \n", sentence_4);

	//======= 포인터 간단 복습 ==========
	char word[30] = { "long sentence" };
	char* str = word; // &word[0]

	printf("%s \n", str);// str이 가리키는 것을 문자열로 출력(즉, 널이 나올 때까지 출력)

	// ====== 문자열 바꾸기 =======
	char word2[] = { "long sentence" }; // 원소의 개수를 지정하는 부분을 빈칸으로 한 것은 컴파일러가 알아서 원소의 개수를 세어 빈칸을 채우라는 뜻.

	printf("조작 이전 : %s \n", word2);

	word2[0] = 'a';
	word2[1] = 'b';
	word2[2] = 'c';
	word2[3] = 'd';

	printf("조작 이후 : %s \n", word2);



	return 0;
}