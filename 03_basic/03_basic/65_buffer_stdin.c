#include <stdio.h>
int main() {
	int num;
	char c;

	printf("숫자를 입력하세요 : ");
	scanf("%d", &num);

	printf("문자를 입력하세요 : ");
	scanf("%c", &c);

	/*
		분명히 우리는 컴퓨터로 하여금 숫자를 입력받은 후, 
		"문자를 입력하세요:"를 출력한 후, c에 문자를 입력받으라고 명령했다.

		그런데 실행 결과를 보면 scanf("%c", &c); 명령을 완전히 무시한다.
		왜 그런지 알기 위해서 scnaf 함수가 어떻게 작동하는 것인지를 먼저 확인해 보자.

		컴퓨터에 무언가 입력하면 컴퓨터는 어떻게 처리 할까?
		예를들어 우리가 컴퓨터에게 abcde를 입력했을 때 컴퓨터가 각 문자를 입력받을 때 마다 처리한다면
		(즉 우리가 a를 누르는 순간 a라는 문자를 변수에 저장하고 등등 작업을 하고 그 다음에 b가 들어오면 다시 이 문자를 ...)
		비효율적일 것이다.

		하지만 우리가 문자를 입력하면 다른 곳에 잠시 보고나해 놓고 우리의 입력이 끝나면
		잠깐 보관해 놓았던 곳의 정보를 한꺼번에 처리하면 어떨까? 따라서 우리가 만일 abcde를 입력하면
		abcde를 잠시 다른 곳에 보관해놓았다가 입력이 끝나면 이를 한꺼번에 처리하는 것이다.

		사실 이 두 방법이 어떤 차이가 있는 지 잘 모르겠다면 아래 비유를 보면 쉽게 이해가될 것이다.

		약수터에서 물을 떠오는데 물을 3L 받아온다고 했을 때
		1) 손에 물을 받아서 약수터까지 수십번 와따가따 하는 것
		2) 양동이를 들고가서 3L를 채운 후, 다시 양동이를 가지고 내려오는 것

		두 방법 중 어떤 것이 합리적인가? 당연히 2번이다.
		컴퓨터의 양동이에 해당하는 부분은 바로 buffer라고 부르는 것이다.

		또한, 수 많은 버퍼 중에서도 키보드의 입력을 처리하는 버퍼는 바로 입력 버퍼
		, 혹은 stdin(흔히 입력 스트림)이라 부르는 것이다.

		다시말해 우리가 키보드로 치는 모든 정보는 일시적으로 stdin에 저장되었다가 나중에 입력이 종료되면 한꺼번에 처리한다.
		그런데, 컴퓨터가 어떻게 우리가 입력을 종료했는지 알 수 있나? 엔터를 치면 된다.
		왜냐하면 이전에도 우리가 계속 보았듯이 엔터를 치기만 하면 입력을 끝내고 프로그램이 계속 실행되었다.

		다시말해 컴퓨터는 개행 문자, 즉 \n을 '입력을 종료했으니 버퍼에 들어 있는 내용을 가지고 놀아라'라는 뜻으로 받아들인다.

		그런데 컴퓨터는 \n까지 버퍼에 저장학 된다. 즉 우리가 1을 쓰고 엔터를 딱 치면 버퍼에 아래와 같은 상태가 된다.
		--stdin -----
		| 1\n        |
		-------------
		입력을 끝냈다면 컴퓨터는 scanf 함수를 이용해서 stdin으로 부터 숫자를 얻어온다. 왜 숫자냐면
		scanf("%d", &num);으로 작성했기 때문이다.
		즉 오직 숫자 데이터만 stdin에서 얻어온다는 말이다.
		그렇다면 scanf 함수는 언제까지 stdin으로부터 데이터를 얻어올까? 바로 ' ', '\n', '\t' 을 만날 때이다.
		(여기서 ' '는 띄어쓰기 한 칸, '\n'은 개행문자(enter), '\t'는 tab을 의미한다.)
		stdin에서 위 3 개의 문자들을 만난다면, 아. 여기서 입력은 끝이구나 하고 입력을 종료한다.

		참고적으로 %d계열의 것들, 
		즉 수를 입력받는 형식은 수가 아닌 데이터가 와도 입력을 종료해 버린다.
		즉 a를 입력했다면 num에는 아무런 값이 들어가지 않아 치명적인 결과를 야기할 수 있다.
		뿐만 아니라 수 데이터를 입력받는 형식의 경우 처음부터 공백문자가 나타나면 수가 나타날 때 까지 계속 입력을 받게 된다.
		다시 말해, 수를 입력 받는데 엔터를 아무리 쳐도 숫자를 치기 전까지 넘어가지 않는다.

		아무튼 scanf 함수는 공백문자(' ', '\n', '\t')를 만나기 전까지 stdin에서 데이터를 가져간 후 버퍼에서 삭제해버린다.
		다시말해, 위 scanf 함수가 num에 1을 저장한 후 버퍼의 모습은 아래와 같다.
		--stdin -----
		| \n        |
		-------------
		이제 우리 말을 아주 잘 듣는 컴퓨터는
		scanf("%c", &c);를 실행하게 된다.
		그런데 %c는 이유를 불문하고 stdin에서 딱 한개의 문자만 가져오게 된다.
		만일 stdin에 아무것도 없다면 사용자의 입력을 기다리고 있겠찌만 stdin에 무언가 있다면 그것을 냉큼 가져온다.
		그런데 공교롭게도 위에서 \n을 버퍼에 남겨 놓았기 때문에 scanf는 냉큼 이를 c에 저장하게 된다.
		즉 c에는 사용자의 입력을 받지 않고 \n을 집어 넣은 것이다.

		따라서 만일 우리가 printf("%c출력 ", c);를 하면 '출력'이 한 칸 개행(엔터)되어 나타난다.

		그렇다면 scanf에서 %s로 받으면 어떻게 될까?
	*/
	char str[30];
	int i;
	scanf("%d", &i);
	scanf("%s", str);

	printf("str : %s", str);
	/*
		이번에는 원하는 결과를 잘 보여준다.
		%c와 달리 %s의 경우 컴퓨터가 사용자로부터 입력을 잘 받는다.

		그 이유는 간단하다.
		scanf("%d", &i)'를 통해 stdin에는 \n이 남아있게 된다.
		그리고 scanf("%s", str);를 실행하게 되면
		역시 수 데이터를 입력받는 형식처럼 실질적인 데이터(공백문자가 아닌 것들)이 나오기 전까지
		버퍼에 남아 있던 공백 문자들은 무시하고 실질ㅈ거인 문제(공백 문자가 아닌 것들)가 입력되면
		그 다음부터 등장하게 되는 공백 문자에서는 종료하게 된다.
		즉 기존에 1을 입력했을 때 남아있던 \n이란 공백문자는 사라지고, 내가 strdafdasfd을 입력하고 난 후 엔터를 쳤을 때 들어가는 \n은 인식한다.

		결론적으로 %s나 %d 그리고 다른 모든 수를 데이터를 입력받는 형식은 버퍼에 남아 있는 공백 문자에 신경쓰지 않고 사용할 수 있다.
		!! 그렇다고 %s를 입력 받은 후 버퍼가 완벽히 깨끗해지는 것이 아니다. 개행문자는 뒤에 남아있다.!!

		하지만 %c를 이용할 때는 버퍼에 무엇이 남아 있는 지 잘 고려해야한다.
		이는 정말 번거로운 일이다.
		물론 이를 대체할 수 있는 멋진 대안이 있지만 이는 조금 있다가 고려하도록하고 다음 예제를 보자.
	*/

	char str1[10], str2[10];

	printf("문자열을 입력하세요 : ");
	scanf("%s", str1);				// hello baby 을 입력하면
	printf("d입력한 문자열 : %s \n", str1); // hello

	printf("문자열을 입력하세요 : ");
	scanf("%s", str2);
	printf("d입력한 문자열 : %s \n", str2);// baby 가 나온다.
	/*
		hello baby를 입력하면 두 번째 scanf를 완전히 무시하고 지나간다.
		이제 우리는 왜 이러한 일이 일어난 것인지 안다.

		stdin이라는 buffer에 "hello baby\n"이 입력된다.
		scanf 함수는 stdin으로부터 의미있는 문자(공백문자를 제외한 문자)가 나올 때까지
		모든 공백 문자를 무시한다.

		위의 경우 stdin에서 처음에 공백 문자가 하나도 없으므로 바로 ㄴtdin으로부터 데이터를 가져온다.
		데이터를 가져오다가 공백 문자를 마나게 되면 입력을 중지한다.
		위의 경우 ' ' 이 공백 문자의 역할을 하기 때문에 str1에는 hello까지만 입력이된다.

		첫 번재 scanf함 수를 지나게 되면 stdin의 모습은 아래와 같다.

		--stdin ----
		|' 'baby\n | (남아 있는 space bar를 ' '로 표현함)
		------------
		두 번재 scanf함수는 stdin에 아무것도 없가나, 공백 문자들 밖에 없다면
		무언가 의미있는 문자를 입력해줄 때까지 기다리겠지만 위 경우는 상황이 다르다.
		일단 처음에 공백 문자인 띄어쓰기는 살포시 무시한다.
		왜냐하면 아직 의미있는 문자를 받지 않았기 때문이다.
		그리고 나서 b를 보고 str2에 입력을 쭉 받기 시작한다.
		그러다가 마지막에 공백 문자인 \n을 보고 입력을 중지한다.

		따라서 메모리에는 \n만 덩그러니 남아있게 된다.
		--stdin ----
		| \n        | 
		------------
		아무튼 scanf는 상당히 이해하기 복잡한 것임은 틀림없다.
		가뜩이나 머리 아픈데 %c를 이용하면 고려해야 될 것이 더욱 많아져 짜증이난다.
		하지만 다행이도 이러한 문제를 해결할 수 있는 방법이 있고 
			실질적으로 %c는 많이 쓰이지 않으니 다행이다.
	*/

	/*
		[도데체 이 문제를 어떻게 해결하냐]
		하지만 아무리 %c를 사용하지 않는다고 해도 필연적으로 사용할 일이 생기게 된다.
		그렇다면 그때마다 이처럼 버퍼에 \n이 남아 있는 것을 고려해야할까?
		정말 번거롭다.

		"버퍼 비우기"
		주의하실 점은 반드시 MS 계열의 컴파일러로 컴파일 해주세요.
		즉 Visual Studio 계열의 컴파일러로!
		이 말이 무슨 말인지 모르면 그냥 늘 하던대로 하면 된다.

		gcc에서는 정상적으로 작동되지 않는 위험한 코드이다.
	*/
	int num2;
	char c2;

	printf("숫자를 입력하세요 : ");
	scanf("%d", &num2);

	fflush(stdin);

	printf("문자를 입력하세요 : ");
	scanf("%c", &c2);
	/*
		먼저 위 소스가 어떻게 올바르게 작동하는지 부터 살펴보자.
		사실 올바르게라는 말 보다는 scanf가 사용자의 입력을 무시하지 않는지가 적당한 표현이다.

		printf("숫자를 입력하세요 : ");
		scanf("%d", &num2);
		여기까지 실행했을 때 이전처럼 stdin에 '\n'이 남아있다.

		그런데 fflush(stdin); 으로 'stdin을 비워라'라는 의밍다.
		다시말해 stdin에 있는 모든 데이터들을 날려버리게 된다.
		그래서 버퍼에 가시처럼 남아 있떤 \n이 사라지게 된다.

		scnaf("%c", &c);
		이러한 상태에서 위의 scanf를 호출하게 되면 %c는 버퍼에 아무것도 남아있는 것이 없으므로
		사용자의 입력을 차분히 기다리게 된다.
		즉 우리가 c에 원하는 값을 넣을 수 있다.

		하지만 프로그램 코드 상단의 무서운 주석을 보면 알겠지만
		fflush가 표준으로 '무슨 역할을 한다.'라고 정해진 것은 아니다.

		즉 VS에선 fflush 함수가 버퍼를 비운느 훌륭한 역할을 하지만 다른것
		예를 들면 gcc같은 데에선 이러한 작업을 하지 않을 가능성이 매우 크다.

		즉 위 방법은 권장되는 방법은 아니지만 적어도 우리의 수준에서 정확하게 작동하고 편리하다.

		그리고 VS2015부터는 표준을 따라서 fflush가 위와 같이 작동하지 않는다.
	*/
	
	// == getchar 함수 이용 ==
	int num3;
	char c3;

	printf("숫자를 입력하세요 : ");
	scanf("%d", &num3);	// 이 문장 실행 후, stdin에 \n이 남아있게 됨

	char temp_ch = getchar();	// stdin에서 한 문자를 읽어와 그 값을 리턴한다. 그리고 그 한 문자가 읽히면 stdin에서 사라지게 됨
	printf("%c", temp_ch); // 이렇게 하면 \n이 출력되서 개행되는 것을 알 수 있다.

	printf("문자를 입력하세요 : ");
	scanf("%c", &c3);
	/*
		getchar 함수를 호출한 방법은 여러 모로 많이 쓰이는 방법이다.
		기본적으로 scanf에서 %c 형식을 사용하는 것을 권하고 싶지는 않지만 정 사용하고자 한다면 
		getchar()을 scanf이전에 호출해서 버퍼를 비워준느 것이다.

		그런데 위의 방법도 문제가 있다.
		만일 버퍼에 한 문자만 남겨져 있는 것이 아니라면 어떨까?

		한 번 숫자 입력시 123abc를 쳐 보았따.
	*/
	int num4, i4;
	char c4;

	printf("숫자를 입력하세요 : ");
	scanf("%d", &num4);

	getchar();

	printf("문자를 입력하세요 : ");
	scanf("%c", &c4);

	printf("입력한 문자 : %c", c4);
	/*
		숫자를 입력하세요 : 123abc
		문자를 입력하세요 : 입력한 문자 : b

		위와 같은 방식으로 출력된다.
		역시 우려했떤 대로 scanf에서 사용자의 입력을 기다리지 않고 지나쳤다.
		뿐만아니라 c에도 우리가 원치 않던 b라는 값이 들어가있다.

		왜 이런 일이 발생한 것인지
		버퍼에서 무슨 일이 벌어지고 있는지 차근차근 살펴보도록 하자.

		printf("숫자를 입력하세요 : ");
		scanf("%d", &num4);
		위의 문장 수행 후 버퍼 상황
		----stdin---
		| 123abc\n |
		------------

		scanf("%d",&num4); 후 상황
		----stdin---
		| abc\n    |
		------------
		%d로 데이터를 읽어올 때 공백문자이나 숫자가 아닌 것을 만나면 stdin에서부터 그만 읽어온다
		a가 숫자가 아니므로 123까지만 읽은 후 stdin에서 그만 읽어온다.

		getchar();실행후
		----stdin---
		| bc\n    |
		------------

		printf("문자를 입력하세요 : ");
		scanf("%c", &c);
		scanf 입장에서 버퍼에 읽어올 것이 잔뜩 있고 한 문자를 읽어오면 되므로
		b가 된다.
		그래서 우리가 원치 않던 b가 들어가게 된다. 그리고 나서 b는 stdin에서 사라지게 되어
		c\n이 남아있게 된다.

		결론은 되도록 %c를 사용하지 말자!이다.
		만일 정말로 문자 하나만을 입력받는 프로그램을 만들려면
		scanf에서 %s 형태로 문자열을 입력 받은 뒤에 맨 앞의 한 문자를 취하는 식으로 만들자!
	*/

	return 0;
}