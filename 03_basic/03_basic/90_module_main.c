#include <stdio.h>
#include "str.h"
// char compare(char* str1, char* str2);
int main() {
    char str1[20];
    char str2[20];

    scanf("%s", str1);
    scanf("%s", str2);

    if (compare(str1, str2)) {
        printf("%s 와 %s 는 같은 문장 입니다. \n", str1, str2);
    }
    else {
        printf("%s 와 %s 는 다른 문장 입니다. \n", str1, str2);
    }
    return 0;
}
/*
    char compare(char* str1, char*str2)를 모듈화 하고 나면
    main이 있는 곳은 이렇게 된다.

    성공적으로 컴파일 하면 아까와 동일한 결과를 얻는다.

    이 프로그램이 어떻게 동작하는 지 살펴보자.

    90_module_main.c            90_module_str.c
      - 컴파일 ->                  - 컴파일 ->
    90_module_main.o            90_module_str.o
                        +
                       링킹
              => 90_module_main.exe

    우리가 실행 파일을 만들기 위해서는 
    먼저 C 코드를 컴퓨터가 이해할 수 있는 언어로 '컴파일(compile)'
    이라는 과정이 진행된다.
    이때, 목적코드라 불리는 확장자가 .o인 파일이 생성된다.

    이 과정이 끝나게 되면 링킹(linking)이라는 과정이 진행되는데
    말그대로 각기 다른 파일에 위치한 소스 코드들을 한데 엮어서
    하나의 실행 파일로 만들어지는 과정이라 생각하면 된다.

    링킹 과정에서 특정하노스 파일에 있는 함수들이 어디어디에 있는지 찾는 과정을 거치게 되는데
    예를 들어 90_module_main.c의 경우 compare 함수가 어디있는지 찾게 된다.
    (printf 함수 역시 찾아야 함을 알 수 있다.)

    이 예제의 경우 compare 함수는 90_module_str.c에 있기 때문에
    링커(링킹 해주는 프로그램)는 '90_module_main.c'에서 compare 함수를 호출하는 경우
    '90_module_str.c'에서 찾아라 정도로 처리해 준다.
    덕분에 우리는 main.c에서 compare 함수를 호출해도 str.c의 compare 함수를 이용할 수 있는 것이다.

    만일 main.c에서 함수의 프로토타입을 지우게 되면 어떻게 될까?
    (char compare(char* str1, char* str2); 를 지우면 어떻게 될까?)

    이렇게 되면 컴파일러는 main 함수에서 comapre 함수를 호출하였는데
    compare 함수가 어떻게 생긴 모양이야!? 가 되어서 컴파일시 오류가 발생한다.
    물론 링커의 경우도 compare 함수의 정확한 모양이 무엇인지 알 수 없으므로 오류가 발생하게 된다.

    따라서 언제나 함수의 선언을 명시해 주는 것은 매우 중요한 일이다.
    
    하지만 compare라는 함수 말고도 copy라는 함수가 str.c에 추가되었다.
    이 함수는 두 문자열을 복사해주는 역할을 한다.
    copy라는 함수를 test.c에서 이용하기 위해선 역시 copy 함수의 원형을 써줘야한다.
    이는 상당히 귀찮은 일이다.
    뿐만 아니라 다른 파일에서도 compare 함수와 copy 함수를 이용할 수 있는데
    이 파일 역시 두 함수의 원형을 써줘야 한다.

    이렇게 귀찮은 작업을 막기 위해 C에선 아주 놀라운 해결책을 제시하였는데
    바로 header file을 이용하는 것이다.

    헤더파일은 솔루션 탐색기에서 "헤더파일-추가-새항목-헤더파일"을 추가하면 되느데
    str을 추가해주면 str.h라는 헤더파일이 추가 됨을 볼 수 있다.

    그리고 헤더파일에서는 #include "str.h"라고 기록하면 된다.
    => str.c와 main.c에 #include "str.h"를 기록 + str.h에 함수의 선언부들을 작성

    #include 와 같은 명령어들은 Preprocessor(전처리기) 명령이라고 부른다.
    이러한 명령어들의 특징은 '컴파일 이전'에 실행된다는 점이다.

    이 명령은 우리가 지칭하는 파일의 내용을 정확히 100% 복사해서 붙여넣는다.
    따라서 #include "str.h"라는 명령은 str.h에 있었던 내용 즉 함수의 선언부로 컴파일이 시작하기 전에 바뀐다.

    그렇다면 #include <stdio.h>는 어떨까?
    이 역시 동일하다. stdio.h에 써 있는 내용들이 정확히 복사되어 컴파일 이전에 코드에 붙어버린다.

    그런데 한 가지 이상한 점은 stdio.h에는 <>로 감쌌는데 str.h는 왜 ""으로 감쌌을까?
    그 이유는 단순하다. <>로 감싸는 헤더파일은 컴파일러에서 기본적으로 지원하는 헤더파일이고
    ""으로 검싸는 헤더파일은 사용자가 직접 제작한 헤더파일이다.

    보통 헤더파일을 만들 때 그 헤더파일에 있는 함수들이 정의되어있는 소스파일의 이름을 따서 짓는 것이 보통이다.
    위 경우 str.h에 선언되어 있는 함수들이 모두 str.c에 정의되어 있으므로 헤더 파일의 이름을 str.h로 하였다.

    한 가지 흥미로운 점은 str.c에서도 str.h를 include 하고 있다는 점이다.
    이는 다음과 같은 상황을 방지할 수 있다.
    // sth.c
    int A(){
        B();
        return 0;
    }
    int B(){return 1;}
    만일 sth.c라는 파일에 위와 같은 소스가 있다고 하자. 이는 100% 오류가 발생된다.
    왜냐하면 A() 함수에서 B()를 호출할 때 B가 무엇인지 모르므로 오류가 발생한다.
    즉 아래와 같이 B()를 위에 선언해 주어야 한다.

    int B();
    int A(){
        B();
        return 0;
    }
    int B() {return 1;}
    하지만 헤더파일을 배웠기에 아래와 같이 하는 것이 더 낫다
    // sth.c
    #incldue "sth.h"
    int A(){
        B();
        return 0;
    }
    int B() {return 1;}

    // sth.h
    int A();
    int B();
*/