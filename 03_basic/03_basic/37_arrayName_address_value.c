/*
	배열 이름에 sizeof 연산자와 주소값 연산자를 사용할 때를 빼고 전부다 포인터로 암묵적 변환이 이루어진다.
	주소값 연산자를 사용하면 어떻게 되길래 그럴까?
*/

#include <stdio.h>

int main() {
	int arr[3] = { 1, 2, 3 };
	// 배열의 이름 자체인 arr은 암묵적으로 int*로 변환된다.
	// 그렇다고 해서 &arr이 int **이 되는 것은 절대 "아니다!!!!!!" 암묵적 변환은 주소값 연산자가 왔을 때는 이뤄지지 않는다.
	// arr이 크기가 3인 배열이기 때문에, &arr을 보관할 포인터는 크기가 3인 배열을 가리키는 포인터가 되어야할 것이다.
	// 그리고 C언어 문법상 이를 정의하는 방식은 아래와 같다.
	// 이때 parr을 정의할 때 *parr을 꼭 ()로 감싸야만 한다.
	// 만일 괄호를 제거하면 int *parr[3]이 되어서 C 컴파일러가 int* 원소를 3개 가지는 배열을 정의한 것으로 오해하게 된다.
	int(*parr)[3] = &arr;	// 크기가 3인 배열을 가리키는 포인터

	printf("arr[1] : %d \n", arr[1]);
	printf("parr[1] : %d \n", (*parr)[1]);	// parr은 크기가 3인 배열을 가리키는 포인터이므로 배열을 직접 나타내려면 * 연산자를 이용해 원래의 배열인 arr을 참조해야 한다

	// 여기서 재미있는 점은 parr과 arr은 같은 값을 가진다는 점이다.
	// arr과 parr 모두 배열의 첫 번째 원소의 주소값을 출력한다. 물론 두 개의 타입은 다르다.
	// 이는 당연한데, arr 자체가 어떤 메모리 공간에 존재하는 것이 아니기 때문이다.
	printf("arr : %p \n", arr);
	printf("parr : %p \n", parr);
	/*
		위와 같이 C언어가 변태적으로 동작하는 이유는 역사에 숨어있다.
		C언어는 B언어에서 파생된 언어인데, B언어에는 실제 배열이 있고 배열을 가리키는 포인터가 따로 있었다.
		B언어에서 arr과 arr[0], arr[1]은 각기 다른 메모리를 차지하는 녀석들이고,
		arr이 실제로 arr[0]를 가리키는 포인터였다.
		따라서 arr의 값을 출력하면 실제로 arr[0]의 주소값이 나왔고 &arr은 arr의 주소값이 나왔다.
		따라서 B언어에서 arr과 &arr은 서로 다른 값을 출력했을 것이다.

		하지만 C언어를 만든 데니스 리치는 B언어의 문법을 계승하되, 비효율적으로 배열이 정의할 때 배열의 시작점을 가리키는 포인터로 공간을 낭비하고 싶지 않았다.
		따라서 조금 이상하지만 메모리 공간을 효율적으로 사용하는 배열-포인터 관계가 탄생하게 되었다.
	*/

	return 0;
}