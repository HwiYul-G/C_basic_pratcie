/*	배열은 배열이고 포인터는 포인트다.
	
	- sizeof 와 주소값 연산자와 함께 사용할 때를 제외하면, 배열의 이름은 첫번째 원소를 가리킨다.
	- arr[i]와 같은 문장은 사실 컴파일러에 의해 *(arr + i)로 변환된다.

	int arr[10]; 이라는 배열을 만든다면 위의 2가지 경우를 제외하면 
		arr이 arr[0]을 가리키는 포인터로 타입 변환 된다.

	그렇다면 int* 포인터가 이 배열(int arr[10])을 가리킬 수 있지 않을까?
*/

#include <stdio.h>

int main() {
	int arr[3] = { 1,2,3 };
	int* parr = arr; // int *parr = &arr[0]; 도 동일하다.

	printf("arr[1] : %d \n", arr[1]);
	printf("parr[1] : %d \n", parr[1]);

	// =========
	int arr[10] = { 100, 98, 97, 95, 89, 76, 92, 96, 100, 99 };

	int* parr = arr;
	int sum = 0;

	while (parr - arr <= 9) {// 0<= parr - &arr[0] <=9. parr - arr >=10이 된다면 parr[10이상의 값]으로 오류가 된다.
		sum += (*parr);
		parr++;
	}

	printf("내 시험 점수 평균 : %d \n", sum / 10);
	/* 
		위의 예제에서 우리는 왜 parr을 따로 선언했을까 ?
		우리는 arr이 arr[0]을 가리킨다는 사실을 알고 있으므로 arr을 증가시켜서 *(arr)으로 접근해도 되지 않을까?
	*/
	int arr[10] = { 100, 98, 97, 95, 89, 76, 92, 96, 100, 99 };
	//arr++;  // error C2105 : '++'에 l-value가 필요합니다.
	/*
		배열의 이름이 첫 번째 원소를 가리키는 포인터로 타입 변경 된다고 했을 때,
		이는 단순이 배열의 첫 번재 원소를 가리키는 주소값 자체가 될 뿐이다.
		따라서 arr++은 C컴파일러 입장에서 (0x 7fff 1234 ) ++ ; 을 수행한 것이 되므로 애초에 말이 안되는 문장이다.
	*/
	return 0;
}