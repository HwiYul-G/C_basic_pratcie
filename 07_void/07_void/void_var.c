#include <stdio.h>

int read_char(void* p, int byte);

int main() {
	void a;
	a = 3;
	/*
		이를 컴파일 하면 error C2182 : 'a' : 'void' 형식을 잘못 사용했습니다.
		와 같은 오류 메시지를 보게 된다.

		리턴타입이 void인 함수를 보았으니 void형 변수도 있을 것 같은데 이는 오류이다.

		컴파일러가 int a; 라는 문장을 보게 된다면
		컴파일러는 int형 변수 a를 선언하는구나, 메모리상에 미리 4byte의 공간을 마련해 놓아야지 라고 생각할 것이다.
		그런데 void a;를 보게 된다면
		이 변수를 위해 메모리 상에 얼마나 많은 공간을 설정해 놓아야하는지 모르게 된다.
		(참고로 컴파일 할 때 모든 변수들의 메모리 상의 위치가 결정되어야 한다)

		그렇다면 void* 는 가능할까?
	*/
	void* b;
	double c = 123.3;
	b = &c;

	printf("%lf", *b); // error C2100 : 간접 참조가 잘못되었습니다.
	/*
		void* b; 의 경우는 위에서 지적한 문제는 없다.
		왜냐하면 void* b의 경우 '포인터'이기 때문에 메모리 상에 8byte 만큼 지정하게 된다.
		즉 b에는 어떠한 지점의 메모리 주소 값이 들어가게 된다.

		그렇다면 void* b 포인터는 void 형의 변수의 메모리 주소를 가지게 될 까?
		물론 논리를 따져보면 맞지만, void형 변수라는 것은 존재할 수 없어서 void형 포인터의 존재는 쓸모 없어 보인다.
		하지만 void는 타입이 없기 때문에 거꾸로 생각해보면 어던 형태의 포인터의 값이라도 담을 수 있게 된다.

		위에서 c2100 오류가 발생하는 이유 역시 쉽게 알 수 있다.
		왜냐하면 컴파일러는 *b가 무엇을 말하는 지 알 수 없기 때문이다.
		여태까지 *b를 해석할 때 컴파일러는 b가 가리키는 것의 타입을 보고 
			메모리 상에서 b부터 얼만틈 읽어들여야할지를 결정했다.

		그러나 void b;의 경우 메모리 상에서 얼만큼을 읽어들여야 할 지 모른다.
	*/
	printf("%lf", *(double*)b); // 잘 출력된다.
	/*
		우리는 위 문장에서 형변환을 이용했다.
		즉 단순히 주소값만을 담고 있는 b에게 (double *)을 취함으로써,
		컴파일러로 하여금 "이 포인터 b가 담고 있는 주소값은 double을 가리키는 주소값이라 생각해"라고 말한 것이다.
		
		따라서 (double *)b 부분을 통해 
		컴파일러는 현재 b가 가리키고 있는 곳의 주소값을 double로 생각하게 되어 8byte를 읽어들인다.

		void형 포인터는 단순히 어떤 타입의 포인터의 주소 값도 편리하게 담을 수 있다.
		그래서 많은 부분에서 활용되고 있다.

		예를 들어, "어떤 특정한 주소값으로부터 1byte씩 값을 읽어오는 함수"를 생각해보자.

		이 함수에는 인자가 2개 전달될 텐데,
		일단 그 특정한 주소값을 가리키고 있는 포인터와 얼마나 읽을지 int형 변수 하나를 받아야한다.

		그런데 인자로 전달된 '특정한 주소값을 가리키고 있는 포인터'의 타입이 제각각이다.
		따라서 우리는 순전히 주소값만을 받기 위해서 void형 포인터를 사용하는 것이 바람직하다고 볼 수 있다.

		물론 포인터 간의 형변환을 통해서 처리할 수는 있지만
		어떠한 형태의 포인터 주소값도 가능하다는 의미를 살리기 위해선 void 형 포인터를 이용하는 것이 바람직하다.


	*/
	int arr[1] = { 0x12345678 };

	printf("%x \n", arr[0]);
	read_char(arr, 4);
	/*
		성공적으로 컴파일 하면
		12345678
		78
		56
		34
		12
		이렇게 출력된다.
		
		역순으로 출력되는 이유는 우리가 쓰는 대부분의프로세서는 리틀 엔디안 방식으로 저장한다.
		따라서 낮은 자리수가 낮은 주소값을 가지게 된다.
		즉 낮은 자리 수인 78이 낮은 주소값인 앞쪽에 저장되게 된다.
		따라서 12 34 56 78순이 아니라 78 56 34 12 순으로 저장되는 것이 맞다.
		
		그렇게 따지면 87 65 43 21 순으로 나타나지 않냐고 물을 수 있는데, 
		저장 단위가 byte 단위이므로 1byte 내에서는 우리가 생각하는 순서와 동일하다.
	*/
	return 0;
}

int read_char(void* p, int byte) {
	do {
		// p가 가리키는 주소값에 위치한 데이터 1byte씩 16진수로 출력하게 된다.
		printf("%x \n", *(char*)p);	// void*인 p를 char*로 캐스팅하고 그것의 *( = 그것의 값)
		byte--;

		p = (char*)p + 1;
	} while (p && byte);
	/*
		p = (char*)p + 1; 
		(char*)p 는 '이 p에 들어있는 값을 char형 변수의 주소값이라 생각해!'라는 의미
		거기서 +1을 했으므로 포인터의 덧셈이 행해진다.
		컴퓨터는 p를 'char형 주소값'으로 생각하므로 p + 1을 수행하게 되면
		주소값이 char의 크기. 즉 1만큼 늘어난다.

		아무튼 이와 같은 방식으로 p의 주소값을 계속 1씩 증가시키는데,
		이때 byte의 값이 0이 되거나 (char *)p의 값이 0 (즉 NULL)일 때 while문이 종료된다.

		do while을 이용한 이유는 
		만일 동일한 조건문으로 while문을 만들게 된다면
		((char*)p)++이 먼저 실행되기 때문에 p부터 읽지 않고 p + 1부터 읽게되는 불상사가 발생하기 때문이다.
	*/
	return 0;
}