/*
	[리턴값이 없는 함수]
*/
#include <stdio.h>

void add_one(int* p) {
	(*p) += 1;
	/*
		add_one 함수는 인자로 전달된 포인터가 가리키는 것의 값을 1로 증가시킨뒤 종료된다.
		그리고 return을 수행하는 문장이 없다.
		왜냐하면 return type이 void형으로 선언되어 있기 때문이다.

		영어 사전을 찾아보면 void는 진공, 공허라는 뜻을 의미한다.
		C언어에 적용해서 생각해보면 '없을 무'의 타입을 의미한다고 볼 수 있다.

		만일 이 함수가 무언가 리턴을 한다면 그 무언가는 타입이 있어야 되기 때문에
		이 void 함수가 가능한 형태는 '아무것도 리턴하지 않는 함수'가 된다.
	*/
}

int main() {
	int a = 1;
	printf("Before : %d \n", a);
	add_one(&a);
	printf("After : %d \n", a);
	return 0;
}
/*
	리턴 타입이 void 함수는 아무것도 리턴하지 않는 함수이므로
	아래의 문장은 모두 틀린 셈이된다.

	void a();
	int main(){
		int i = a();
		return 0;
	}
	void a(){}

	즉 함수 a가 리턴하는 값이 없으므로 i의 값에 a의 리턴값을 대입할 수 없다.
	이 모두 오류로 처리된다.

	void 형 함수는 많은 곳에서 사용된다.
	주로 리턴을 할 필요가 없는 함수들의 경우가 대부분이다.

	예를 들어서 두 변수의 값을 교환하는 ㅎ마수를 생각해보자.
	우리는 지금까지 아래와 같은 형태로 함수를 만들었다.

	int swap(int *a, int *b){
		int temp = *a;
		*a = *b
		*b = temp;
		return 0;
	}

	하지만 swap 함수는 리턴할 필요가 없는 함수이다.
	단순히 두 수의 값만 바꾸면 되는데 뭐하러 귀찮게 리턴을 하냐..
	오히려 불필요하게 swap의 리턴 타입이 있다면 
	swap 함수를 사용하는 사람 입장에서 이 함수의 리턴 값은 무슨 의미지? 를 생각해야한다.

	하지만 아래와 같이 void 로 함수를 만든다면 그런 걱정은 깔끔하게 날릴 수 있다.
	void swap(int *a, int *b) {
	  int temp;

	  temp = *a;
	  *a = *b;
	  *b = temp;
	}
*/