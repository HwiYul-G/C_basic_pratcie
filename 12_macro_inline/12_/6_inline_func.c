/* 인라인 함수 */

#include <stdio.h>
__inline int square(int a) { return a * a; }
int main(int argc, char** argv) {
	printf("%d", square(3));

	return 0;
}
/*
	__inline int square(int a) { return a * a; }
	__inline을 빼고 본다면 단순히 square라는 함수를 만든데 지나지 않는다.
	또한 printf에서도 역시 함수를 호출했던 것처럼 똑같은 방식으로 사용한다.
	
	하지만 이는 함수와는 전혀 다른 행동을한다.
	함수의 경우 호출을 하게 되면 프로그램의 흐름이 완전히 다른 곳으로 넘어가게 된다.

	예를 들어서
	int cubic(int a) {return a*a*a; }
	와 같이 3제곱을 하는 '평범한' ㅎ마수 하나를 만들고 main 함수에서 
	int main(int argc, char **argv) {
		printf("%d", cubic(3));
		return 0;
	}
	와 같이 cubic 함수를 호출하게 된다면, cubic(3)을 실행 시, 
	프로그램의 흐름이 main 함수를 벗어나 메모리 어딘가에 위치한 cubic 함수에 찾아가서
	인자로 3을 전달하고 27을 맅하는데, 그 리턴 값을 가지고 다시 main 함수로 돌아오게 된다.

	이렇게 함수를 사용하게 되면 프로그램의 흐름이 기존의 함수 내부에서 벗어나 다른 함수에 들렸다가 오게 되는데
	이러한 과정을 줄여서 "함수를 호출하는 과정"이라고 말하게 된다.

	이렇게 함수를 호출하게 되면 단순히 a를 3번 곱하는 작업인데도 시간이 꽤 걸리게 된다.
	즉 cubic 함수처럼 단순한 작업만을 하는 함수의 경우에는 굳이 함수로 따로 만들 필요 없이 
	차라리 main 함수 내에서 printf("%d", 3*3*3);으로 하는 것이 훨씬 효율적이다.

	이러한 생각을 살려 만든 것이 inline 함수이다.

	위에서 inline 형식으로 만든 square 함수는 우리가 생각하는 함수가 전혀 아니다.
	단순히 함수처럼 보이는 것일 뿐이다.

	inline 함수를 사용하면 마치 매크로 함수처럼
	printf("%d", square(3)); 이 printf("%d", 3 * 3);와 동일해진다.

	한 가지 매크로 함수와 차이점이 있따면 매크로 함수와 달리, 인라인 함수는 전처리기가 무식하게 치환하는 것이 아니다.
	매크로 함수를 사용했었을 땐 전처리기가 무식하게 치환해 버리는 바람에 
		연산자 우선순위를 정확히 고려해서 괄호도 적당히 묶어주고 해야 했다.
	인라인 함수의 경우 똑똑한 컴파일러가 인라인 함수를 사용한 문장 내부에서 적절하게 '우리가 보통 함수를 사용하는 것처럼' 바꿔준다.

	즉 printf("%d", square(3 + 1));와 같은 문장은 보통 함수를 사용하는 것처럼 되므로
	printf("%d", (3 + 1) * (3 + 1));로 변경된다.
*/