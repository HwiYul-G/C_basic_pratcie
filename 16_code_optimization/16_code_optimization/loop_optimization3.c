/*
	loop 관련

	1) 알고 있는 일반적인 결과를 이용하라.
	대표적으로 이야기 하자면 1부터 n까지 더하는 함수를 만들 때이다.
	일반적으로 이러한 작업을 한느 코드를 짤 때에는
	for(int i = 1; i<=n; i++){
		sum += i;
	}
	하지만 위처럼 일일히 더하는 것 말고도 공식을 통해
	sum = (n+1)*n /2; 로 간략하게 나타낼 수 잇다.
	이렇게 하면 많은 계산 시간을 절약하게 된다.

	2) 끝낼 수 있을 때 끝내라
	아래 코드는 특정한 문자열 'a'라는 문자가 포함되어 있는 지 검사하는 코드이다.
	while(*pstr){
		if(*pstr != 'a'){
			does_string_has_a = 1;
		}
		pstr++;
	}
	위 코드에서 does_string_has_a 가 한 번 1이 되었다면
	뒤에서 바뀔 일이 없으므로 굳이 루프를 끝까지 실행한느 것은 무의미한 짓이다.

	이때 이런 곳에서 break문을 넣어서 빠져 나갈 수 있게 한다면 
	불필요한 실행을 줄일 수 잇다.
	while (*pstr) {
		if (*pstr != 'a') {
			does_string_has_a = 1;
			break;
		}
		 pstr++;
	}

	3) 한 번 돌 때 많이 해라.
	하나의 루프에서 동일한 일을 2번 하는 것과 하나의 루프에서 동일한 일을 한 번 하고
	루프를 두 번 돈다면 전자의 경우가 훨씬 효율적이다.
	왜냐하면 루프를 한 번 돌 때 
	여러가지 조건들이 맞는지 비교하는 부분에서
	시간이 약간 소모되지 때문이다.
	따라서 되도록이면 루프 한 번에 안에서 많은 일을 해버리는 것이 중요하다.

	아래 코드는 정수 n에서 값이 1인 비트가 몇 개나 존재하는 지 세는 프로그램이다.
	while(n != 0){
		if(n & 1){
			one_bit++;
		}
		n>>1;
	}
	위 코드는 맨 끝에 한개의 bit를 검사하고 오른쪽으로 shift해서
	또 다시 맨 끝 비트를 검사하는 식으로 해서
	결과적으로 모든 비트를 검사해 값이 1인 것의 개수를 센다.
	하지만 우리는 C언어에서 모든 정수 자료형의 크기가 8bit의 배수임을 알고 있다.

	예를 들면 char은 1byte로 8bit, int는 4byte로 32bit이다.
	따라서 굳이 1개의 bit씩 검사할 필요 없이 8bit를 한꺼번에 묵어서 검사해도 상관없다.
	이때 8bit를 한꺼번에 비교하면 너무 난잡하므로 4bit씩 비교하는 것이다.

	while(n != 0){
		if(n&1) one_bit++;
		if(n&2) one_bit++;
		if(n&4) one_bit++;
		if(n&8) one_bit++;
		n >>= 4;
	}
	이렇게 하면 루프 도는 회수를 줄일 수 있어서 어느정도 시간 절약 효과를 보게 된다.

	4) 루프에서는 되도록 0과 비교해라
	for(int i = 0; i<10; i++)
		printf("a");

	for(int i = 9; i != 0; i--)
		printf("a");

	위의 2개의 for문 중 무엇이 더 빨리 실행될까?
	실제론 큰 차이는 없지만 엄밀히 따지고 보면 아래의 루프가 더 빠르게 돌아간다.
	왜냐하면 위 루프의 i가 10보다 작은지 비교하고 있고
	아래의 루프는 i가 0과 다른지 비교하고 있는데
	일반적으로 0과 비교하는 명령어는 CPU에서 따로 만들어져 있어서 더 빠르게 작동할 수 있다.


	5) 되도록 루프를 적게 써라
	int i;
	for (i = 1; i <= 3; i++) {
		func(i);
	}
	보다
	
	func(1);
	func(2);
	func(3);
	와 같이 루프를 푸는 것이 더 좋을 때가 있다.
	물론 루프를 쓰면 무엇을 하는 지 한 번에 알 수 있찌만
	for문 자체에서 여러가지 비교를 수행한느데 시간이 들기 때문에 위와 같이
	루프를 쓰지 않고도 나타낼 수 있다면 그 방법을 선택!
*/