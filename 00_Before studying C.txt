★★https://modoocode.com/315
모두의 코드님이 제작하신 씹어먹는 C 강의를 보고 적으면서 읽으면 학습에 도움이 되어서 동일하게 적은 내용입니다.★★


C언어는 1972년에 출시된 언어이다.
C언어는 유닉스 운영체제를 작성하기 위한 목적으로 만들어졌다. 즉, '시스템 프로그래밍'이 주 목적이였기에, C와 컴퓨터 시스템과 밀접한 관계가 있다. 따라서 시스템 관련 배경 지식을 모른다면 C 언어를 처음 접할 때 까다로울 수 있다.

C 언어가 시스템 프로그래밍용 언어로 처음 출발한 만틈,
컴퓨터 시스템에 대한 이해가 필요하다.

1. 컴퓨터란?
= 일련의 연산을 수행하는 계산기

컴퓨터와 계산기는 계산을 한다는 점에서는 본질적으로 큰 차이가 없다. 컴퓨터를 컴퓨터 답게 만드는 이유는 바로 명령어를 읽어들여서 주어진 명령어에 따라 연산을 수행한다. 

=> 1) 누가 명령어를 읽는가?
     2) 어디서 명령어를 읽는가?
     3) 프로그램이란게 뭐지?
     4) 명령어는 어떻게 작성하는가?

2. 누가 명령어를 읽는가?
컴퓨터의 모든 연산은 중앙 처리 장치, CPU(Central Processing Unit)이라 불리는 작은 반도체에 의해서 처리된다.

CPU는 대충 1초에 10억번 개의 연산을 처리하고 그런만틈 엄청난 양의 열을 발생한다. 따라서 보통은 쿨러 밑에 숨어있다.
물론 컴퓨터 그래픽 관련 연산이 늘어나 그래픽 관련 연산들만 전문적으로 처리하는 GPU가 있다. GPU는 행렬 연산 전문이다. CPU와 같이 다양한 종류의 명령어를 처리할 수는 없다. 

GPU의 경우 그래픽에 관련된 명령어들은 CPU와 비교할 수 없을 정도로 빠른 속도로 처리한다. 
즉 CPU는 똑똑한 친구들 1-2명이, GPU는 조금 덜 똑똑한 친구들이 수백 수천명이 모여서 일하는 것이다.

3. 어디서 명령어를 읽는가?
CPU가 명령어를 처리한다. 이를 위해 실행할 명령어를 읽어야하고 연산된 결과를 어디엔가 저장해야한다.

명령을 수행하는 공간인 CPU 안에 실행할 명령어들도 저장해 놓고 그 결과도 CPU 안에 있으면 좋겠지만 데이터를 저장해놓을 공간이 매우 부족하다.

CPU가 연산을 수행하기 위해서 데이터를 저장하는 공간을 register라고 부르는데 64bit CPU의 경우 일반적인 연산을 수행할 수 있는 레지스터는 총 16개 밖에 없다.

그리고 각 register에 64bit의 데이터를 담을 수 있다.
즉 CPU에 최대한 많이 넣어도 들어갈 수 있는 데이터의 크기는 최대 128byte(128*8bit) 뿐이다.

레지스터는 cpu 안에 있는 메모리라 cpu 안에서 연산을 수행 시에 매우 빠르게 접근할 수 있다. 하지만 레지스터의 개수를 늘리는 것은 기술적으로 어렵기 때문에 cpu 밖에 저장공간이 필요하다. 

이렇게 cpu 옆에 붙어서 저장공간 역할을 하는 장치가 바로 RAM이다. RAM은 Random Access Memory의 줄인 말이다.

RAM은 CPU의 조그마한 레지스터에 비해 비교할 수 없을 만큼 큰 용량을 제공한다. 8GB 정도의 램의 경우 CPU의 레지스터의 크기(128byte)와 비교해서 약 6천만 배 이상 크다.

따라서 CPU는 램에 실행할 명령어들을 저장해놓고 있다가, 연산을 수행할 때 램에서 읽어들이게 된다. 그리고 필요한 데이터는 램에서 꺼내 쓰거나 저장해 놓는다.

이러한 램은 큰 단점이 있는데 바로 '휘발성 메모리'라서 전기가 있을 경우만 유지가 되어 전원이 공급되지 않으면 메모리에 저장되어 있는 데이터가 모두 날아가게 된다.

컴퓨터를 항상 켜놓을 수는 없기에 컴퓨터가 꺼져도 데이터를 유지할 수 있는 저장 장치가 필요하다. 이때 등장한 것이 바로 HDD와 SSD이다. 이들은 램과 달리 전기 공급 없이도 데이터를 안정적으로 보관할 수 있다. 물론 램과 비교했을 시 데이터를 읽어들이는 작업은 훨씬 느리다.

통상적으로 CPU에서 램에 있는 데이터를 가져오는데 100 나노 초가 걸린다고 보는데, SSD의 경우 50~150 마이크로초, 하드디스크의 경우1-10밀리초가 걸린다.

CPU는 평균적으로 0.3 나노초마다 1번 연산을 수행ㅎ나ㅡㄴ데, 하드디스크에서 데이터가 올 때까지 기다리는데 약 3천만번의 연산을 수행할 수 있다. 만일 CPU가 매번 HDD에서 명령어를 읽어들인다면 엄청난 시간을 낭비하게 된다.
따라서 보통 컴퓨터 프로그램을 실행하면
1) HDD에 저장되어 있는 프로그램의 위치를 찾아서 램에 복사해놓는다
2) CPU는 램에서 명령어를 읽어들여서 실행을 한다.

하지만 CPU에서 RAN에 접근하는 속도도 빠른 편이 아니다. 50 나노 초는 CPU에서 연산을 150번 수행할 수 있는 시간이다. 이런 문제로 CPU에는 비록 직접적인 연산을 수행할 수는 없지만, 빠르게 데이터를 레지스터에 불러올 수 있는 저장 공간으로 캐시(Cache)라는 것을 사용한다. 

캐시는 계층별로 L1, L2, L3 캐시로 이루어져있다.
L1 캐시의 경우 크기가 제일 작지만 (보통 256KB) 레지스터와 가장 인접한 캐시로 L1 캐시에 저장되어 있는 데이터를 읽는 데는 1나노초 밖에 걸리지 않는다. 따라서 데이터를 읽는데 기다리는 시간을 최소화할 수 있다. L3 캐시의 경우 대충 28나노 초 정도 걸리지만 크기가 제일 크다. (~16MB).
따라서 보통 지금 가장 필요한 데이터의 경우 L1 캐시에 들어가게 되고, 그 중요도에 따라 필요성이 낮으면 낮을 수록 L2, L3 캐시에 배치된다.

CPU는 자기가 조만간 사용할 것 같은 데이터들을 미리 캐시에 불어온다. 또한 램에 데이터를 저장할 때도 바로 램에 쓰는 것이 아니라 캐시에 잠시 써놨다가 여유가 생기면 램에 적는 방식을 사용한다.

물론 CPU가 미래에 실행할 명령어를 미리 볼 수 있는 것이 아니라, 램에서 어떤 데이터가 필요할지 알 수 없다. 따라서 CPU는 여러가지 예측 알고리즘을 사용해서 캐시의 적중률을 높이려고 하는데 대개 램의 전체 데이터를 중구 난방으로 사용하는 것보다는 특정 부분만 반복적으로 접근하는 경우에 캐시 적중률이 높아진다.

물론 CPU가 요청한 데이터가 캐시에 없을 수 있다. 이를 Cache miss라고 하며 이 경우 램에서 필요한 데이터를 불러 오느라 상당히 시간이 지체된다. 빠르게 동작하는 프로그램을 설계하기 위해선 캐시 미스 확률을 낮게 하는 것이 중요하다.

3. 명령어는 어떻게 작성하는가?
CPU가 램에서 데이터를 읽어오기 위해서는 램의 어디에서 데이터를 읽을지를 말해줘야한다. 램에 있는 모든 데이터는 1바이트의 단위로 0번을 시작으로 고유의 address가 부여되어 있다.

램은 크기가 1바이트(2진수로 8자리수)짜리 데이터를 보관할 수 있는 수 많은 방들로 구성되어 있다. CPU는 램에게 "어디에서" 데이터를 읽을 지를 알려준다면 램은 해당 위치에 있는 데이터를 즉시 전달해준다.

마찬가지로 어디에다 데이터를 저장할지를 알려준다면 램은 해당 위체 있는 데이터를 CPU가 전달한 데이터로 바꿔치기한다. 그래서 그 위체 있던 데이터는 사라진다.

중요한 점은 해당 주소값으로 부터 "얼마 만틈" 읽어야 할지도 말해줘야 한다. 램 상에서는 데이터의 경계가 없다. 예를 들어서 0x1234라는 주소값에서 부터 단 한칸(즉 1byte)만 읽어야할 수도 있고, 4칸(4byte)를 읽어야할 수도 있다. 이렇게 얼마만틈 읽어야 할 지는 명령어 단계에서 지정해준다.

예를 들어 우리가 CPU에게 주소값 0x1234에 1byte만큼 3이라는 데이터를 저장하고 싶다고 하면 아래와 같은 순서로 명령어를 내려야한다.
1) CPU의 레지스터에 접근하고자하는 주소값 0x1234를 저장한다. 편의상 a라는 레지스터에 저장했다고 하자
2) 이제 a에 젖된 주소값에서부터 1byte 부분까지 3을 저장해 라는 명령을 내린다. 

위 명령을 실제 사용되는 CPU 명령어로 재현하면 아래와 같다. 이와 같이 CPU가 직접적으로 해석하는 명령어를 Assembly라고 한다. 물론 CPU는 0과 1로 된 전기 신호만을 받아서 해석하지 이 명령어들을 알파벳 그대로 받는 것은 아니다. 다만 어셈블리 명령어와 실제 CPU가 읽어들이는 데이터와 1대 1대응이 되어 있기 때문에 사람이 그나마 읽기 편하도록 영어 명령어로 바꿔서 표현한다.

mov는 대입해라 라는 명령어이다.
mov A, B : A에 B를 대입해라

mov eax, 4660 # 4660은 0x1234를 십진수로 나타낸것
move BYTE PTR [rax], 3 

exa라는 이름의 레지스터에 0x1234라는 값을 대입해라
rax라는 이름의 레지스터에 들어 있는 값을 주소값으로 생각해서 해당 위치에 3을 대입해라는 문장 ([]가 그 역할을 함)

BYTE PTR은 전달한 주소값으로부터 1바이트 만큼 데이터를 우리가 저장할 값(3)으로 덮어 씌우라는 의미이다.

rax와 eax는 같은 레지스터를 의미한다.
64bit cpu에는 64bit 크기의 레지스터가 16개 있다고 했는데, rax는 그들 중 한 레지스터를 의미한다. 그리고 eax의 경우 rax 레지스터의 마지막 32bit를 의미한다.

0x1234의 경우 크기가 2*32보다 작기 때문에 레지스터의 마지막 32bit 안에 기록할 수 있다. 따라서 레지스터에서 eax를 읽든 rax를 읽든 똑같이 0x1234가 읽히게 된다.

아무튼 정확히 0x1234 한 칸에만 우리가 원하는 데이터 (3)가 들어갔다.

만약에 1byte 말고 4byte 영역에 3을 쓰고 싶다면 어떨까요? 
3은 0x0003이므로 0x1234에는 3이 들어가겠지만, 나머지 3칸에는 0이 들어가게된다.

mov eax, 4660
mov DWORD PTR[rax], 3

DWORD PTR의 경우 4byte만큼을 보라는 의미이다.

그런데 왜 move DWORD PTR[4660], 3은 안될까? 그 이유는 CPU가 위와 같은 명령어를 허용하지 않기 때문이다. 위와 같이 메모리주소값에 해당하는 데이터를 접근하기 위해선, 먼저 그 주소값을 레짓터에 집어 넣고 해당 레지스터를 참조해야 한다.

64bit 시스템 CPU의 레지스터의 크기가 바로 8byte라는 점에 주목해야한다. 그 이유는 당연히, 레지스터에는 주소값을 저달할 수 있어야 하는데, 64bit 시스템에서 주속밧은 8byte 이기에, 레지스터도 8byte가 되는 것이다.

8byte로는 2^64개의 수를 표현할 수 있다. 큰 수이지만 엄청나게 큰 수를 표현하기엔 무리가 있다. 따라서 cpu로 매우 큰 정수의 연산을 다루기 위해서는 8byte 단위로 쪼개서 따로따로 연산을 해야 한다.

4. CPU가 명령어를 읽어들이는 방법
cpu는 주소값을 통해서 램에 어디에 접근할지 명령하게 된다. 그런데, cpu가 독자적으로 명령을 내릴 수 있는 것은 아니다. CPU가 명령을 내리기 위해선 해당 명령어를 어디선가 가져와야 한다. 이렇게 CPU에 실행할 명령어를 제공하는 것을 "프로그램을 실행한다."라고 한다.

프로그램은 실행할 명령어와 데이터들의 집합이다. 
프로그램을 실행하면, 컴퓨터 운영체제가 CPU에게 램에 위치에 있는 프로그램의 시작점을 알려주게 되고 그 이후로 CPU는 해당 위치부터 명령어를 쭉쭉 읽어나가며 실행하게 된다.

여기서 중요한 점은 CPU가 현재 램의 어디에서 명령어를 읽어야 할지를 계속 알아야 한다는 점이다. 이는 CPU 안에 지금 읽어들일 명령어의 위치(instruction pointer)만을 보관하는 특별한 레지스터 덕분에 가능하며, 인텔 64bit cpu의 경우 해당 레지스터의 이름은 'RIP'이다.

우리가 컴퓨터에서 어떤 프로그램일 실행한다. 그러면 HDD나 SSD같은 저장 장치에 있는 프로그램 파일을 메모리에 복사하는 작업을 해야하는데 이를 OS가 한다.

한 가지 중요한 점은 메모리에 "여기는 명령어들이 있는 곳이고 여기는 데이터들이 있는 곳이다."라고 써있지 않다는 것이다. 따라서 CPU의 관점에선 메모리의 특정 주소값을 읽으라고 했을 때 뭐가 데이터고 뭐가 프로그램 명령어인지 알 수 없다. 그냥 OS가 프로그램에서 처음으로 실행할 명령어의 위치를 CPU에게 알려주고 난다면 그냥 그려러니 하고 거기서부터 명령어들을 읽어나가게 된다.


5. 그런데 프로그램이 하나만 실행하는게 아니잖아?
우리는 프로그램을 여러 개 실행시킨다. 인터넷을 돌리고 그림판을 키고 하면 실제 ram에 여러 가지 프로그램들이 각각 구역에서 뒤엉켜 있다.

CPU에서 원하는 위치에 데이터를 쓰거나 가져오기 위해서는 메모리의 주소값을 전달해야한다고 했다.
mov eax, 4660
move DWORD PTR[rax], 3
0x1234(십진수로 4660)에 위치해 있는 곳에서 4byte만큼의 공간에 3이라는 값을 쓰라는 명령어이다.

그런데 램에서 이미 여러 프로그램들이 돌아가는데 어떻게 0x1234라는 공간을 사용할 수 있다고 보장할 수 있을까?

만약 지금 0x1234라는 위치에 있는 공간을 어떤 프로그램도 사용하지 않고 있기에 3이라는 값을 잘 써 넣을 수 있다고 하자. 그런데 이전에 이미 실행되고 있뜬 프로그램이 0x1234 부분을 사용하고 있다면 어떨까? 만을 위 코드가 실행되었다면 다른 프로그램의 데이터를 손상시키게 된다.

이를 해결하기 위해선 다른 메모리 주소를 사용하도록 프로그램 명령어 자체를 다시 작성해야 한다. 이를 프로그램 실행할 때마다 매번 하는 것은 불가능하다.

따라서 CPU에서는 메모리를 좀 더 효율적으로 관리하기 위해서 특별한 메커니즘을 제공한다.

6. 가상 메모리 vs 물리 메모리
CPU가 0x1234에 3이라는 데이터를 쓰라는 명령을 내리면 메모리의 주소값 0x1234의 위치에 3을 쓰게 된다고 했는데 사실 거짓말이다. 왜냐하면 이렇게 되면 앞의 문제를 해결할 수 없기 때문이다.

따라서 시제로 CPU가 보는 0x1234라는 주소값과 실제 메모리의 0x1234 주소값은 차이가 있다. CPU가 참조하는 0x1234라는 주소값은 특별한 1대 1 변환 과정에 의해서 실제 메모리의 주속밧을 변호나하게 된다. 이렇게 변환된 주소는 0x1234가 될 수도 잇고 아니면 아예 0x12345678처럼 전혀 다른 곳에 이는 메모리 주소값이 될 수도 있다.

CPU가 참조하는 메모리 주소값을 가상 메모리 virtual memory라고 하고, 일련의 변환 과정에 의해 참조하게될 실제 메모리 주소값을 물리 메모리(physical memory)라고 한다.

이러한 변환 방식을 페이징(paging)이라고 하고, 변환이 되는 최소의 메모리 단위를 페이지(page)라고 한다. 페이지의 크기는 여러 가지로 설정할 수 잇찌만 대부분의 경우 1페이지는 4KB 정도이다.

어떻게 변환을 수행할 지 기록한 테이블을 '페이지 테이블'이라고 한다. 이 페이지 테이블은 각 프로그램마다 하나씩 가지고 있다. 덕분에 구글 크롬에서의 0x1234와 그림판의 0x1234가 실제로는 다른 물리 메모리 주소를 참조할 수 있다. 각 프로그램 별로 고유의 페이지 테이블을 가지고 이씩 때문에 같은 가상 메모리 주소를 사용해도 다른 물리 주소를 의미할 수 있다.

재미있는 점은 64bit 시스템의 경우 사용 가능한 가상 메모리 크기는 2^64 byte로 대략 1844만 TB 정도 된다. 
이렇게 큰 크기의 메모리를 모두 필요할 일은 없어서 os 단에서 2^64범위의 모든 주소값을 지원하지는 않는다. 보통 canonical address라고 해서 특정한 형태의 주소값만을 사용 가능한데 이 크기는 대략 2^48정도(256TB정도)이다. 이 정도도 왠만한 컴퓨터 시스템에서는 충분히 큰 크기이다.

우리가 사용하는 메모리 크기는 16GB정도이다 하지만 페이징 덕분에 2^64 바이트 가상 메모리 공간 그 어디에 기록을 해도 페이지 테이블을 통해 현재 내가 사용가능한 크기 이내의 물리 주소로 변환을 하게 되면 문제없이 사용할 수 있다.

심지어 경우에 다라서 메모리의 올라가 있는 전체 프로그램이 필요로 하는 메모리가 지금 내가 가지고 있는 물리 메모리의 용량 보다 더 큰 경우도 해결 가능하다. 만일 프로그램이 요구하는 메모리에 비해서 현재 사용 가능한 메모리가 적다면, 안 쓰는 페이지부터 HDD에 복사해놓고 해당 페이지를 메모리를 필요로 하는 프로그램에 제공하는 것이다.

만약 HDD에 복사해놓은 페이지를 다시 필요로 하면 os가 해당 페이지를 다시 메모리에 복사해주면 된다.

이렇게 페이징 덕분에 각 프로그램들은 마치 자기 혼자서 메모리 전 공간을 사용하는 것 마냥 생각할 수 있다. 메모리에 같이 올라가 잇는 다른 프로그램들은 전혀 고려할 필요가 없다.

== 정리 ==
- 모든 연산은 CPU에서 수행된다. 정확히 말하자면 CPU의 작은 레지스터 상에서 수행된다 64bit cpu의 경우 레지스터의 크기는 8byte 이다.
- cpu는 무슨 연산을 할 지 알려주는 명령어와 명령어를 실행하기 위해 필요로 하는 데이터를 메모리에서 읽는다.
- 우리가 프로그램을 실행한다는 것은 hdd에 잠들어 있는 명령어들과 데이터를 메모리에 쓰는 것이다. 그리고 os가 cpu에 처음 실행해야할 명령어의 주소값을 전달함으로써 프로그램이 시작된다.
- cpu에는 캐시가 있어서 메모리 접근 횟수를 줄일 수 있다.
- 각 프로그램은 마치 자신이 방대한 메모리 공간 전체를 사용하는 것처럼 생각하며 작동한다.
- cpu에서 참조하는 주속밧은 실제 물리 메모리 주소값이 아니라 가상 메모리 주속밧이다.
- 가상 메모리 주속밧은 각 프로그램의 페이지 테이블을 통해서 실제 메모리 주소값으로 변환된다.




