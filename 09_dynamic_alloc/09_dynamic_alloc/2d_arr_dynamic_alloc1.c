/*
	[2차원 배열 동적할당]
	1) 포인터 배열을 사용해서 2차원 배열처럼 동작하는 배열 만들기
	2) 실제로 2차원 배열 크기의 메모리를 할당한 뒤 2차원 배열 포인터로 참조하는 방법

	1) 포인터 배열을 사용해서 2차원 배열처럼 동작하는 배열 만들기
	포인터 배열 : 배열의 각 원소들이 모두 포인터인 배열
	따라서, 각 원소들이 다른 일차원 배열들을 가리킬 수 있다.
	
	우리가 해야할 일은 먼저 포인터 배열을 동적으로 할당한 뒤
		다시 파오니터 배열 각각의 원소들이 가리키는 일차원 배열을 다시 동적으로 할당해주면
	마치 2차원 배열을 만든 것과 같은 효과를 낼 수 있다.
*/
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char**argv) {
	int x, y;
	int** arr; // 우리는 arr[x][y]를 만들 것이다

	printf("arr[x][y] 를 만들 것입니다.\n");
	scanf("%d %d", &x, &y);

	arr = (int**)malloc(sizeof(int*) * x); // int*형의 원소들 x개를 가지는 1차원 배열 생성

	for (int i = 0; i < x; i++) {
		arr[i] = (int*)malloc(sizeof(int) * y);
	}

	printf("생성 완료! \n");

	for (int i = 0; i < x; i++) {
		free(arr[i]);
	}
	free(arr);
	
	/*
		int **arr부터 보자
		int arr[3]; 이란 배열을 만들었다면 arr의 형은 int*이다.
		그렇다면 int* arr[10]; 이란 배열을 만들었으면 arr의 형은 int**이다.

		따라서 int** arr; 과 같이 선언했다.

		arr = (int **)malloc(sizeof(int *) * x);
		이 부분으로 int*형 배열을 동적할 당 할 수 있었다.
		이 과정을 거치면 arr은 int*을 가리킬 수 있는 공간이 x개 생긴다. (각 공간의 크기는 8byte)

		arr배열의 각 원소들은 int*이므로 다른 int형 배열을 가리키기를 갈망하고 있을 것이다.
		for (int i = 0; i < x; i++) {
			arr[i] = (int*)malloc(sizeof(int) * y);
		}
		이를 통해 각각의 원소들에 대해 메모리 공간을 할당하고 있다.
		arr[i]는 malloc이 정의한 또다른 공간을 가리킨다.
		이 공간은 int형을 담는 방이 y개 이다.

		따라서 arr의 하나의 원소의 크기가 y인 배열을 가리키고 있는데 arr의 원소의 개수가 x개 이므로
		전체적으로 보았을 때 총 x*y 배열을 가지는 셈이다.
		하지만 이렇게 만들어진 배열은 정확히 말해 2차원 배열이라 말하기는 힘들다.

		왜냐하면 배열은 모름지기 메모리에 연속적으로 있어야하기 때문이다.
		하지만 우리가 만든 배열은 arr의 원소들이 가리키는 메모리 공간이 연달아 존쟇다고 보장할 수 없다.
		또한 한 가지 재미있는 점은 우리가 만든 '2차원 배열 처럼 생긴' 포인터 배열은 
			2차언 배열과 달리 함수의 인자를 손쉽게 넘길 수 있다.

		예를 들면 int array(int **array); 처럼 가능하다.
		array(arr); 을 하게 되면 우리가 만든 배열을 함수에 넘길 수 있게 된다.

		이게 가능 한 이유는 사실 우리가 만든 배열은 1차원 배열들이지 2차원 배열이 아니기 때문이다.
		arr은 단순히 int*형 원소들을 가지는 1차원 배열이다.
		1차원 벼앨을 함수의 인자로 넘겨줄 때에는 크기를 써주지 않아도 되었다.
		사실 main함수의 인자로 전달되는 argv역시 이와 같은 성격을 띈다.

		그렇다고 해서 2차원 배열의 성질을 잃어버리는 것은 아니다.
		이 배열도 2차원 배열처럼 arr[3][4]와 같이 원소에 접근할 수 있다.
		(그렇기 때문에 우리가 만든 이 배열을 2차원 배열이라 부르는 것이다.)
		
		왜냐하면 arr[3][4] 는 *(*(arr+3)+4)로 해석되는데, *(arr + 3)을 통해 arr의 네 번째 원소에 접근하게 되고
		*(arr+3)은 자신이 가리키는 int형 배열의 주소값을 의미하므로 + 4를 하면 int형 배열의 5번째 원소에 접근하는 것과 같다.
		
		아무튼 이와 같은 방법으로 2차원 배열(사실은 다르지만 이렇게 부르자)를 생성했다.
		우리가 이 배열을 힙에 할당하였으면 사용이 끝나고 되돌려 주어야 한다.

		해제하는 순서는 할당하는 순서와 정 반대로 하면 된다.
		즉, arr[i]들이 가리키고 있떤 int 배열들을 해제한 후, arr을 해제하면 된다.

		만일 arr을 먼저 해제하면 arr[i]들이 메모리 상에서 사라지게 되므로 arr[i]들이 가리키고 있던
		int 배열들을 해제할 수 없게 되므로 오류가 난다.


		
	*/

	return 0;
}