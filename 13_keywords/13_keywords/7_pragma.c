/*
	#pragma 는 컴파일러에게 말하는 전처리기 명령이다.
	즉 #include나 #define 처럼 전처리기에 의해 컴파일 이전에 처리되지만,
	그 명령은 컴파일러에게 전달되기 때문이다.

	사실 pragma는 C언어의 기본 키워드라고 하기 보다는
	컴파일러에 종속적인 키워드라고 하는 것이 맞다.
	pragma를 사용하는 문법은 컴파일러마다 다르고 딱히 통힐된 것이 없기 때문이다.

	여기선 pragma를 사용하는 몇 가지 예제들을 보고
	어떤 경우에 편리하게 pragma를 사용할 수 있는 지 살펴보자.
*/
#include <stdio.h>
struct Weird {
	char arr[2];
	int i;
};
int main() {
	struct Weird a;
	printf("size of a : %d \n", sizeof(a));	// 8
	return 0;
}

/*
	분명히 Weired라는 구조체 내의 원소들의 총 바이트 수를 계산해보면
	arr은 char형 변수 2개 이므로 2byte이고
	i는 int형 변수 1개로 4byte이므로 총 6byte가 나와야 정상이다.

	그런데 왜 도대체 컴퓨터는 이들을 8로 출력했을까?

	왜냐하면 실제로 메모리 상에서 이 구조체의 크기를 8byte로 컴파일러가 지정했기 때문이다.
	현재 우리가 사용하는 컴퓨터에서는 언제나 4byte 단위로 모든 것을 처리하는 것이 빠르다.
	따라서 언제나 컴퓨터에서 데이터를 보관할 때는 4의 배수로 데이터를 보관하는 것이 처리시 용이하다.
	이렇게 데이터가 4의 배수의 경계에 놓인 것을 "더블 워드경계에 놓여있다." 라고 한다.

	이러한 이유 때문에(빠르게 하기 위해)
	Weired 구조체 역시 4의 배수를 맞추기 위해 크기를 8byte로 '필요 없는 2byte를 추가하면서 까지' 맞춘 것이다.
	이 문제가 중요하게 여겨지는 부분은 역시 HW간의 통신 때문에 그렇다.

	예를 들어서 SCSI 인터페이스는 PC에서 하드 디스크와 같은 주변기기에 연결하기 위한 통신방식이다.
	SCSI 장치들에게는 읽기 명령을 내리기 위해서 6byte의 명령어를 전송하면 된다.
	이 6byte의 명령어는 구조는 꽤 복잡해서 흔히 구조체로 많이 이용하는데
	만일 위와 같이 그냥 사용했다가는 구조체의 크기가 8byte로 설정되어 있어서 무슨 문제가 생길지 알 수 없다.

	이렇게 컴파일러로 하여금 구조체를 더블 워드 경계에 놓지 말라고 하고 싶을 때
	pragma 키워드를 이용하면 된다.

	==> 8_pragma.c로
*/